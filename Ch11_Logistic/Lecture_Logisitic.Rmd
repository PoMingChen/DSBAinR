---
title: "Lecture_Logistic"
author: "PoMingChen"
date: "8/15/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Env setting

```{r}
library("tidyverse")
library("magrittr")
library("reshape2")
library("InformationValue")

```

```{r message=FALSE}
internal.data <- read_csv("internal_data.csv") 
head(internal.data)
internal.data$credit_card_vendor <- as.factor(internal.data$credit_card_vendor) ##發卡信用卡單位，必定是factor
# internal.data$user_id #user_id，必定是character
```

```{r message=FALSE}
survey.data <- read_csv("survey_data.csv")
```

```{r message=FALSE}
colnames(internal.data)
```

- "user_id"            
- "dm_message"         
- "dm_post"           
- "dm_email"           
- "credit_card_vendor"
- "credit_card_bonus"  
- "coupon"   

```{r message=FALSE}
colnames(survey.data)
```

- "user_id"         
- "is_loyal"        
- "depart_on_time"  
- "arrive_on_time"  
- "register_method" 
- "register_rate" (註冊方式滿意度)
- "class"           
- "seat_rate"    (座艙滿意度)   
- "meal_rate"    (餐點滿意度)
- "flight_rate"  (航班滿意度)  
- "package_rate" (行李滿意度)    
- "tv_ad"        (有看過電視廣告)
- "youtube_ad_1" (有看過youtube廣告1)
- "youtube_ad_2" (有看過youtube廣告2)  
- "youtube_ad_3" (有看過youtube廣告3)  

```{r}
complete.data.test <- internal.data %>% inner_join(x=., y=survey.data, by="user_id")
complete.data <- internal.data %>% merge(x=., y=survey.data, by="user_id")
```

```{r}
# 底下用`dummy.data.frame`會不成功，可能跟資料本身是tibble/data.frame有關係
class(complete.data.test)
class(complete.data)
```


```{r message=FALSE}
complete.data.test$credit_card_bonus <- as.factor(complete.data.test$credit_card_bonus)
complete.data.test$register_method <- as.factor(complete.data.test$register_method) 
complete.data.test$class <- as.factor(complete.data.test$class)
```


```{r message=FALSE}
complete.data$credit_card_bonus <- as.factor(complete.data$credit_card_bonus)
complete.data$register_method <- as.factor(complete.data$register_method) 
complete.data$class <- as.factor(complete.data$class)
```


```{r}
complete.data.test %>% class()
complete.data %>% class()
```

## Data Transformation

> In situations where we have categorical variables (factors) but need to use them in analytical methods that require numbers (for example, K nearest neighbors (KNN), Linear Regression), we need to create dummy variables.

[Useful Link1](https://subscription.packtpub.com/book/big_data_and_business_intelligence/9781783989065/1/ch01lvl1sec21/creating-dummies-for-categorical-variables)

[Useful Link2](https://www.r-bloggers.com/conversion-between-factor-and-dummies-in-r/)

```{r}
library(dummies) ##Create dummy/indicator variables flexibly and efficiently
```


> #The `dummy.data.frame` can only use in the data.frame, tibble is not acceptable. So, there is a need to convert the factor(catogerical vaiables) to dummy on my own. Here is a small practice(and realize) follow the two links above.

> 這邊算是老師用的`merge`這個函數本身的限制。他的output是一個dataframe，縱使我當初給的兩個都是tibble。那`dummy.data.frame` 只能用在data.frame，自然`inner_join`是出來還是tibble，所以就會產生問題。

> 另外也稍微複習到`model.matrix`轉乘dummy，with intercept and without intercept的兩種可能性。

```{r}
complete.data.test.new2 <-  dummy.data.frame(complete.data.test, 
                                            sep = "_",
                                            dummy.classes = 'factor')
```

```{r}
predict(dummyVars(~ credit_card_vendor+credit_card_bonus+register_method+class, 
            data = complete.data.test,
            sep = "_",
            fullRank = F), newdata = complete.data.test) %>% as_tibble() -> Dummy.Table

## fullRank parameter: If TRUE, factors are encoded to be consistent with model.matrix(with intercept) and the resulting there are no linear dependencies induced between the columns.
```


```{r}
complete.data.test %<>% cbind(Dummy.Table)
complete.data.test %>% colnames()
complete.data.test %<>% select(1:4, -c(5:6), 22:24, 25:28, 7:10, c(-11,-13), 29:32, 33:35,12:21) 

complete.data.test %<>% select(1:19, 23, 20:22, -24, 25:32)

complete.data.test
```


#### 老師的方法
```{r}
complete.data.new <- dummy.data.frame(complete.data,
                                      sep = "_", 
                                      dummy.classes = 'factor')
##sep = "_"；For the names of the created dummy variables, sep is the character used between the variable name and the value. (e.g. State_NY, State_PA , State_CA，中間那個底槓你如何用來表達新產生的眾多新變數之區分)

##dummy.classes = 'factor'；A vector of classes names for which dummy variables are created(e.g.你想要針對哪一種類型的變數，轉換成Dummy，dummy.classes = 'factor'就是針對factor的變數
```


```{r}
##到目前為止，用老師方法和自己轉的都ok了。 原則上只要cor reshape系列畫出來的圖ok就沒問題。
complete.data %>% colnames()
complete.data.test %>% colnames() 
complete.data.new %>% colnames()
```

## EDA

> 這邊，我們用`complete.data.new`和`complete.data.test`都畫一下熱力圖，看看自己處理的Data Transformation過程是否ok，後來看起來是沒問題。

```{r}
cor(complete.data.new[, 2:ncol(complete.data.new)])[1:5, 1:5]
```

```{r}
cor(complete.data.test[, 2:ncol(complete.data.test)])[1:5, 1:5]
```

我通常喜歡使用熱圖 (heatmap) 視覺化變數間的相關程度，如果要使用 ggplot2 繪製相關係數的熱圖，必須先將資料整理成「變數 1 - 變數 2 - 相關係數」的 data frame，我們可以利用 `reshape2`套件中的melt函數輕鬆把矩陣格式轉換成上述的 data frame。

```{r}
head(melt(cor(complete.data.new[, 2:ncol(complete.data.new)])), 5)
```

```{r}
head(melt(cor(complete.data.test[, 2:ncol(complete.data.test)])), 5)
```

接著我們就可以用geom_tile(繪製方形圖)繪製相關係數的熱圖囉！
```{r}
ggplot(melt(cor(complete.data.new[, 2:ncol(complete.data.new)])),
       aes(Var1, Var2)) +
  geom_tile(aes(fill = value), colour = "white") + ## color = "white"是為了產生周圍的白色邊框。
  scale_fill_gradient2(low = "firebrick4", high = "steelblue",
                       mid = "white", midpoint = 0) +
  guides(fill=guide_legend(title="Correlation")) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title = element_blank())
```

```{r}
ggplot(melt(cor(complete.data.test[, 2:ncol(complete.data.new)])),
       aes(Var1, Var2)) +
  geom_tile(aes(fill = value), colour = "white") + ## color = "white"是為了產生周圍的白色邊框。
  scale_fill_gradient2(low = "firebrick4", high = "steelblue",
                       mid = "white", midpoint = 0) +
  guides(fill=guide_legend(title="Correlation")) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
        axis.title = element_blank())
```

## Data Modeling

### 只考慮內部行銷資料的模型 分析

首先，我們先建立只考量「行銷因素」的邏輯迴歸模型。在 R 語言中，我習慣使用內建的 glm 函數 (glm = generalized linear model)，主要要填入的參數有：

1. __模型公式__：假設你的想建立的邏輯迴歸模型反應變數為Y
，解釋變數為 X1
 與 X2
，可以輸入 Y ~ X1 + X2。
2. __資料集合__：輸入 `data = dataset.name` 即可，記得變數的名稱要與模型公式中的名稱完全符合。
3. __模型種類__：由於 `glm` 不只適用於邏輯回歸，如果你希望建立邏輯迴歸模型，請使用 `family = binomial(link="logit")`。


```{r}
marketing.model <- glm(is_loyal ~ dm_message + dm_post + dm_email +              
                         credit_card_vendor + credit_card_bonus + 
                         tv_ad + youtube_ad_1 + youtube_ad_2 + youtube_ad_3, 
                       data = complete.data, family = binomial(link="logit"))
```


對客戶忠誠度有顯著正面影響 (α=0.05) 的變數：
dm_post, dm_email, credit_card_bonus3, credit_card_bonus4, tv_ad, youtube_ad_2

對客戶忠誠度有顯著負面影響 (α=0.05) 的變數：
dm_message, youtube_ad_1
```{r}
summary(marketing.model)
```

接下來，我們利用 predict(model, data, type) 函數得到模型估計的ℙ(Y=1|X1,⋯,Xp)
：

- `type = "response"`：得到每一個個體的機率。
- `type = "term"`：得到每一個個體 βi⋅Xi的數值。

```{r}
#第二個參數是complete，是原始資料的資料表，就是要用marketing.model來預測他出來的機率是多少？
predict.prob <- predict(marketing.model, complete.data, type = "response")
predict.prob
```

```{r}

```

